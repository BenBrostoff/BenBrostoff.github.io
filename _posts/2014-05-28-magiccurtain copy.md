---
layout: post
title: Behind the Magic Curtain
date: 2014-05-28 
---

My Gregorc thinking style is concrete sequential, according to this [online test](http://www.thelearningweb.net/personalthink.html).

Quite honestly, I've never put stock in tests of this nature and view them in some respects the same way Donnie Darko views [spectrums](https://www.youtube.com/watch?v=MqAJ5W2wQH4). However, I have over the years come to realize things about myself as a learner that seem to align with concrete sequential types [as outlined by Gregorc](http://web.cortland.edu/andersmd/learning/gregorc.htm). 

For instance, I learn best when the subject material is complete and coherent - limitless complexity keeps me up at night. Computer science is simultaneously wonderful and frustrating for me in that if you keep looking down the rabbit hole, what you find generally makes sense - unfortunately, the rabbit hole is infinitely deep (and usually disseminates into electrical engineering jargon). 

My main challenge over the last month has been accepting the fact that I can't understand everything all at once - certain aspects of Ruby and Rails I have been forced (to a degree) to accept as [automagic](http://catb.org/jargon/html/A/automagically.html) (thank you Michael Hartl for introducing me to this term). In order to conform to the bootcamp model (become a programmer in three months!), it's necessary to learn a lot of "how" without the "why" to support it. 

I suppose in our age of incredible complexity we have to make this sacrifice. Lest we forget Clarke's Third Law:

> Any sufficiently advanced technology is indistinguishable from magic. 

I've thought about this quote all through the last several months. Ruby has a lovely library of documentation and some truly incredible mixins, modules, gems, etc. Too often, I find myself using certain tools without viewing the source code. By doing so, I always feel a bit queasy - I know I'm leveraging off someone else's work without completely understanding it. 

This queasy feeling is something I know I need to better come to terms with if I'm ever to be a value-add programmer. I'll always go out of my way to understand "why", but realize technology moves quickly, and a bootcamp's [advantage](http://benbrostoff.github.io/2014/05/23/cultural-week-8/) over a university program in part is its focus on pragmatism. Again, "how" and "why" aren't mutually exclusive, but trying to understand every aspect of software and hardware is beyond even the greatest minds of our generation (or any previous generation at that). 

Adding to the difficulty of balancing between "how" and "why" is the fact that my previous career - banking - was relatively easy to decipher re: "why". We pitched our clients fee-generating products: our clients used these products to the extent that they offered a  sufficiently low cost of capital. 

"How" was also a known commodity - secured and unsecured bonds, ABS deals and equity raises are known processes that can be accomplished in easy to understand steps. We even made T&Rs - timing and responsibility sheets - to show clients exactly what we're doing at any exact moment in time.  

Imagine a T&R in the software world (or really, any part of the tech world) - no self-respecting engineer can claim to be able to tell a client exactly what they'll be doing every week for 8+ weeks. In software development, multiple processes run concurrently, and unforeseen bugs and a host of other issues have the potential to destroy the most well-crafted timeline (I highly recommend Tracy Kidder's [The Soul of a New Machine](http://www.amazon.com/The-Soul-A-New-Machine/dp/0316491977) as evidence here).
 
For a concrete sequential thinker, the endless extended metaphors and abstractions in computer science can be a lot to handle at once. I have come to appreciate activities like exercising and driving because the path from A to B is so clear and well-defined. Indeed, my profession for two years was getting from A to B using an easy-to-follow roadmap (albeit a roadmap that had some long and winding roads). 

Programming is never a straight shot from A to B, and this part of the field is what makes it such a challenge. One cannot distill the production of useful software into a step-by-step process. Precisely because of the complexity underlying software development, it *feels* like magic in the Clarke's third law sense. 

Yet, concrete sequential learner or otherwise, I'm not averse to seeing what's behind the magic curtain.
