<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ben Brostoff</title>
    <description></description>
    <link>http://benbrostoff.github.io/</link>
    <atom:link href="http://benbrostoff.github.io//feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Endless Learning</title>
        <description>&lt;p&gt;There is an infinite amount of knowledge to consume and an average human only lives &lt;a href=&quot;http://www.who.int/gho/mortality_burden_disease/life_tables/situation_trends/en/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;71.4 years&lt;/strong&gt;&lt;/a&gt;. I wanted to write this post to remind myself of 1) why the current landscape for learning is so excellent and 2) strategies that work for mining this landscape for its excellence.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;An Excellent Landscape&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;There are lots of fantastic, thoughtful writers. The amount of superb programming blogs in particular impresses me – &lt;a href=&quot;http://jvns.ca/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Julia Evans&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;http://geoff.greer.fm/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Geoff Greer&lt;/strong&gt;&lt;/a&gt; are at present my two favorites. &lt;a href=&quot;http://waitbutwhy.com/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Wait But Why&lt;/strong&gt;&lt;/a&gt; by Tim Urban is basically free books on interesting topics (thanks to my friend Max for showing me this awesome &lt;a href=&quot;http://waitbutwhy.com/2015/05/elon-musk-the-worlds-raddest-man.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;4 part WBW series on Elon Musk&lt;/strong&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;The podcasting landscape – since I started listening to podcasts – has never been better. &lt;a href=&quot;http://fourhourworkweek.com/podcast/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Tim Ferriss&lt;/strong&gt;&lt;/a&gt; lands superb guest after superb guest. &lt;a href=&quot;http://www.stuffyoushouldknow.com/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Stuff You Should Know&lt;/strong&gt;&lt;/a&gt; is an hour learning about brand new stuff. And I’ll always listen to &lt;a href=&quot;https://soundcloud.com/the-bill-simmons-podcast&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Bill Simmons&lt;/strong&gt;&lt;/a&gt; wax poetic on basketball for an hour.&lt;/p&gt;

&lt;p&gt;Netflix promises whatever thing you happen to be interested in. I just watched &lt;a href=&quot;http://www.bbc.co.uk/programmes/b0074t4x&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Planet Earth: Seasonal Forests&lt;/strong&gt;&lt;/a&gt; and learned more about the biosphere than at any point of being an adult.&lt;/p&gt;

&lt;p&gt;I have been consuming these great things in part by abandoning my “traditional” media sources. In high school and college I had various mentors tell me to read the Wall Street Journal religiously – I admit I don’t do that any more.  While that seemed like sound advice at the time, I feel I am learning more by foregoing newspapers. WSJ, NYT and the Boston Globe – the three newspapers that I see lying around most often – seem to have become obsessed with gossipy political stories.&lt;/p&gt;

&lt;p&gt;Books are always what I learn the most from.  Blogs and podcasts lead to strong book recommendations. Greer’s &lt;a href=&quot;http://geoff.greer.fm/2016/01/04/on-learning-c-part-1-k-r/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;four part series on learning C&lt;/strong&gt;&lt;/a&gt; led me to purchase &lt;a href=&quot;http://www.amazon.com/Programming-Language-Brian-W-Kernighan/dp/0131103628/ref=pd_sim_14_1?ie=UTF8&amp;amp;dpID=41qX6YdIJ7L&amp;amp;dpSrc=sims&amp;amp;preST=_AC_UL320_SR244%2C320_&amp;amp;refRID=1B6FHHVSB9JKW4TVBCMG&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;K&amp;amp;R&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;http://www.amazon.com/Computer-Systems-Programmers-Perspective-Edition/dp/0136108040&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Computer Systems: A Programmer’s Perspective&lt;/strong&gt;&lt;/a&gt;. Ferriss’s podcast has been responsible for me reading the following books: &lt;a href=&quot;http://www.amazon.com/Not-Fade-Away-Short-Lived/dp/006073731X&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Not Fade Away&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;http://www.amazon.com/Influence-Psychology-Persuasion-Robert-Cialdini/dp/006124189X&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Influence&lt;/strong&gt;&lt;/a&gt;, the &lt;a href=&quot;http://www.amazon.com/Art-Learning-Journey-Optimal-Performance/dp/0743277465&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Art of Learning&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;http://www.amazon.com/War-Art-Winning-Creative-Battle/dp/1501260626&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;The War of Art&lt;/strong&gt;&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;I’ve been lucky to have fantastic friends who led me to read books that changed my life. &lt;/p&gt;

&lt;p&gt;Chris – thank you for Tony Bramwell’s &lt;a href=&quot;http://www.amazon.com/Magical-Mystery-Tours-Life-Beatles/dp/0312330448&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Magical Mystery Tours&lt;/strong&gt;&lt;/a&gt;. I still have your copy. &lt;/p&gt;

&lt;p&gt;Joseph – a big tip of the hat for &lt;a href=&quot;http://www.amazon.com/Obstacle-Way-Timeless-Turning-Triumph/dp/1591846358&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;The Obstacle is the Way&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;http://www.amazon.com/Deep-Work-Focused-Success-Distracted/dp/1455586692&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Deep Work&lt;/strong&gt;&lt;/a&gt;. I still travel with &lt;a href=&quot;http://www.amazon.com/Meditations-Thrift-Editions-Marcus-Aurelius/dp/048629823X&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Meditations&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dad – thank you for &lt;a href=&quot;http://www.amazon.com/Values-Game-Bill-Bradley/dp/0767904494&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Values of the Game&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Being Selective&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;There is an endless amount of learning to be done, and no better time to do it. I understand the temptation to endlessly bemoan targeted ads and sponsored content and promotional tweets. However, I really believe these things can be easily avoided. For me, here are the strategies that have worked:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Two books per month, at the same time&lt;/em&gt; - I listed this one first because it has easily been the most useful. Since 2014, I have been trying to read at least 20 books per year - you can see &lt;a href=&quot;http://benbrostoff.github.io/books/&quot;&gt;&lt;strong&gt;my progress here&lt;/strong&gt;&lt;/a&gt;. The two per month will get me a little beyond this goal. I try my best to make these two books extremely different so switching between them is interesting. For instance, right now I’m reading Neal Stephenson’s &lt;a href=&quot;https://www.amazon.com/Snow-Crash-Neal-Stephenson-ebook/dp/B000FBJCJE?ie=UTF8&amp;amp;qid=&amp;amp;ref_=tmm_kin_swatch_0&amp;amp;sr=&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Snow Crash&lt;/strong&gt;&lt;/a&gt; and Doris Kearns Goodwin’s &lt;a href=&quot;http://www.amazon.com/Team-Rivals-Political-Abraham-Lincoln/dp/0743270754&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Team of Rivals&lt;/strong&gt;&lt;/a&gt;. The former is a sci-fi thriller that takes place partly in reality and partly in the metaverse, a VR centered manifestation of reality. The characters use a funny, futuristic slang and there’s lots of violence, gore and riffs on computers. The latter (disclaimer: I’ve been reading this on and off since February in part because it’s 944 pages) follows Lincoln’s rise to the presidency through his death, while also simultaneously following the members of his war cabinet - William H. Seward, Salmon P. Chase and Edward Bates. &lt;em&gt;Rivals&lt;/em&gt; in both chronology and tone is the opposite of &lt;em&gt;Snow Crash&lt;/em&gt;, which makes reading them at the same time awesome. And having both on Kindle makes it easy to switch from one to the other.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Twitter selectivety&lt;/em&gt; - I can’t think of many bigger timesinks than scrolling through Twitter. That said, a lot of people I follow from time to time tweet out high quality reads I never would have found myself. For every one of these tweets, maybe five or six occur in between which are less interesting, or require context to even understand (which then requires more scrolling through Twitter). &lt;a href=&quot;https://twitter.com/pmarca&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Marc Andreessen&lt;/strong&gt;&lt;/a&gt; is perhaps the biggest example of this phenomenon. A lot of tools exist for parsing out the good tweets. I built one for myself because I wanted to use Go - &lt;a href=&quot;https://github.com/BenBrostoff/twitter-news&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;my little JSON API&lt;/strong&gt;&lt;/a&gt; finds the top tweets from a user’s last 200 from a couple people I find particularly interesting. &lt;a href=&quot;http://nuzzel.com/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Nuzzel&lt;/strong&gt;&lt;/a&gt; is the other solution I use, which basically highlights links that multiple people I follow tweet.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Pocket and Rex&lt;/em&gt; - I’ve been using &lt;a href=&quot;https://getpocket.com/a/queue/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Pocket&lt;/strong&gt;&lt;/a&gt; for two years and &lt;a href=&quot;https://itunes.apple.com/us/app/rex-share-recommendations/id965827767?mt=8&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Rex&lt;/strong&gt;&lt;/a&gt; for two months. My Pocket strategy is simple but works well for me - during the weekdays, I pocket a bunch of stuff while I eat lunch at my computer and then read it on Saturday / Sunday mornings. As an aside, Pocket is also good for those times when you come across a Stack Overflow post not really directly related to the thing you’re working on, but nonetheless interesting. If a friend e-mails or texts me a link, I’ll pocket it immediately. Rex, still in its relative infancy as an app, is good because users can only recommend stuff. Said another way, there’s no outlet for debates or vitriol or trolling like on Twitter. As Rex’s CEO helpfully pointed out to me, Rex links are easily Pocketable, and it may have a public API in the future, which would allow for some awesome customization possibilities.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Making some time for daily news&lt;/em&gt; - I enjoy following sports and the stock market on a regular basis, as well as keeping tabs on tech and foreign affairs news (really, anything that is not the 2016 presidentia race). I find headline scanning on ESPN, Bloomberg and Hacker News is generally sufficient to accomplish this task, where I’ll pocket the longer reads if they seem good. I have little cron jobs that allow me to keep up with my &lt;a href=&quot;https://github.com/BenBrostoff/Fantasy-Baseball-Scraper&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;fantasy baseball team&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/BenBrostoff/daily_stock_report&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;stock portfolio&lt;/strong&gt;&lt;/a&gt;. Stuff like this is a good excuse to do some programming with new tools and languages (i.e. no pressure situation).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Conclusion&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Life is short, and reading material is long. I feel a lot more satisfied with my free time since I abandoned newspapers and focused exclusively on good blogs, books and podcasts. Being disciplined with the books I read each month, using Twitter in a highly selective way, and combining Pocket and Rex functionality has helped me discover good material. The daily news I’m interested in I can get through headline scanning and automated web scraping scripts.&lt;/p&gt;

</description>
        <pubDate>Sat, 28 May 2016 00:00:00 -0400</pubDate>
        <link>http://benbrostoff.github.io//2016/05/28/endless-learning/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2016/05/28/endless-learning/</guid>
      </item>
    
      <item>
        <title>Devotion to Craft</title>
        <description>&lt;p&gt;A couple of my favorite things: the documentary &lt;a href=&quot;http://www.rottentomatoes.com/m/meru_2015/&quot; target=&quot;_blank&quot;&gt;Meru&lt;/a&gt;, the essay &lt;a href=&quot;http://www.newyorker.com/magazine/2014/04/21/in-deep-2&quot; target=&quot;_blank&quot;&gt;In Deep&lt;/a&gt;, the 30 for 30s on &lt;a href=&quot;http://espn.go.com/30for30/film?page=into-the-wind&quot; target=&quot;_blank&quot;&gt;Terry Fox&lt;/a&gt; and &lt;a href=&quot;http://espn.go.com/30for30/film?page=the-birth-of-big-air&quot; target=&quot;_blank&quot;&gt;Dave Mirra&lt;/a&gt;. In all of them, there are people who in the truest sense of the words are &lt;em&gt;willing to risk life and limb for their craft&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;That is exceedingly rare in a world where we have all the things we need and more.&lt;/p&gt;
</description>
        <pubDate>Sun, 08 May 2016 00:00:00 -0400</pubDate>
        <link>http://benbrostoff.github.io//2016/05/08/caring-about-craft/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2016/05/08/caring-about-craft/</guid>
      </item>
    
      <item>
        <title>Reading Code</title>
        <description>&lt;p&gt;I think reading code is the best way to improve as a software engineer.&lt;/p&gt;

&lt;p&gt;I like lists for standardizing processes with many steps. To this end, I thought I’d make a checklist of things I’ve come to realize are my own best techniques as they relate to reading code. The central question they all get at - &lt;i&gt;If asked to explain and defend every engineering decision made in whatever piece of code I’m reviewing, could I do it?&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Anyways, the checklist:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Can I run the code successfully on my local environment? If I had to do a bunch of manual configuration, could any of this configuration be automated and checked into source control? If not, does the project Wiki need to be updated to include the manual configuration steps?&lt;/li&gt;
  &lt;li&gt;Does the code solve the issue or implement the feature it set out to resolve? If it’s tied to a GitHub issue, JIRA ticket, etc., does it satisfy whatever criteria was outlined in the issue or ticket?&lt;/li&gt;
  &lt;li&gt;Can I hit breakpoints in the code additions and follow a stack trace back to the entry point? &lt;/li&gt;
  &lt;li&gt;If there is exception handling, can I hit the error cases and see that they’re handled as expected?&lt;/li&gt;
  &lt;li&gt;Can I differentiate between 1) standard library calls, 2) third-party library calls and 3) internal project calls? (importantly, &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/#imports&quot; target=&quot;_blank&quot;&gt; this list corresponds to the order of imports in PEP-8&lt;/a&gt;)
    &lt;ul&gt;
      &lt;li&gt;On standard libary calls - if there are methods I’m not familiar with, did I look at the official docs and find an example case? Did I sandbox the method in the shell and try a few simple test cases? If I’ve never worked with the language, am I developing a familiarity with the types / scoping / syntax, etc?&lt;/li&gt;
      &lt;li&gt;On third party library calls - same as above, but a few additions. Do I generally understand the point of the library? Does the library have a set of best practices? &lt;/li&gt;
      &lt;li&gt;If the library is a wrapper around a broader technology (e.g. &lt;a href=&quot;https://pypi.python.org/pypi/elasticsearch-dsl&quot; target=&quot;_blank&quot;&gt;elasticsearch-dsl&lt;/a&gt;), do I know what’s really going on beneath the language wrapper? For instance, if I’m using an API wrapper, can I reproduce what the wrapper is doing via &lt;code&gt;curl&lt;/code&gt;? If the library is totally foreign to me and I’m guessing at what it may do, do I need to purchase an O’Reilly book or spend an hour or so perusing the docs / tutorials / etc.? &lt;/li&gt;
      &lt;li&gt;One more on libraries - is the library the latest version or an older one? Is the version frozen? Should it be if it’s not?&lt;/li&gt;
      &lt;li&gt;On internal project calls - are these calls self-explanatory or is there a history around what’s going on I need to be aware of? Have I turned on annotations in whatever IDE I’m using (or &lt;code&gt; git blame &lt;/code&gt; if not using an IDE) and tried to understand the related commits?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;If the language I’m working in is dynamically typed, do I have an appreciation for which types are being handled? Am I sight reading or actually setting breakpoints and confirming my intuition is correct?&lt;/li&gt;
  &lt;li&gt;Would I have done anything differently from an architectural perspective (throwing aside style or organization)? Are there risks in whatever I’m reviewing that the use-case if one-off and will have to be totally ripped out and rebuilt in the future?&lt;/li&gt;
  &lt;li&gt;If I’m making suggestions, are they actually good ones in that they 1) improve performance, 2) improve readability and 3) allow for easy building on top of whatever I’m reviewing?&lt;/li&gt;
  &lt;li&gt;If I’m making stylistic suggestions, does the linter need to be changed so it picks them up?&lt;/li&gt;
  &lt;li&gt;If I’m making organizational suggestions (method extraction, refactoring something into a module, etc.), am I simply shifting pieces around or actually making the project more maintainable in the long-term?&lt;/li&gt;
  &lt;li&gt;If I see something I really like or find interesting, did I file it away for future reference? Am I making sure to go back to this reference over time and trying to implement the patterns in it?&lt;/li&gt;
  &lt;li&gt;Do I have a strong understanding of how to deploy this code? What differences need to be taken into account when thinking about non-local environments?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I wrote this list mainly so I could review it for my own reference, but I’d love for it to be useful to other people. I know I’m missing stuff and would love for this post to grow over time - shoot me an email at &lt;a href=&quot;mailto:ben.brostoff@gmail.com&quot;&gt; ben.brostoff@gmail.com&lt;/a&gt; with suggestions.	 &lt;/p&gt;

&lt;p&gt;** I think the original influence for the question above was &lt;a href=&quot;http://www.scotthyoung.com/learnonsteroids/grab/TranscriptFeynman.pdf&quot; target=&quot;_blank&quot;&gt;The Feynman Technique.&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 02 Dec 2015 00:00:00 -0500</pubDate>
        <link>http://benbrostoff.github.io//2015/12/02/Reading-Code/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2015/12/02/Reading-Code/</guid>
      </item>
    
      <item>
        <title>Automation Via Aliasing and Bash</title>
        <description>&lt;p&gt;I’ve been trying to make a concerted effort recently to automate more stuff. Working on a side project or open source project you haven’t touched in a while I’ve found can be annoying to get back into - first navigate to the directory, run a few tasks to set up the DB, install dependencies, pull from master, etc.&lt;/p&gt;

&lt;p&gt;With that in mind, I’ve taken to some aggressive aliasing on a few side projects to get to the fun stuff more quickly. I thought I’d jot down a few interesting takeways from the experience.&lt;/p&gt;

&lt;p&gt;All of the below assume you have a &lt;code&gt;.bash_profile&lt;/code&gt; set up. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On your home setup, it’s worth having aliases to navigate to a project immediately. &lt;/li&gt;
  &lt;li&gt;For setup tasks, it’s tempting to chain together a bunch of terminal commands with &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, but bash functions I’ve found make for easier edits in the future and are more elegant as well.
&lt;script src=&quot;https://gist.github.com/BenBrostoff/398a5ca5397d6a950e64.js&quot;&gt;&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;For anything that involves sshing into another machine, it’s nice to alias:
&lt;script src=&quot;https://gist.github.com/BenBrostoff/dfa397492f727862ccc5.js&quot;&gt;&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;Finally, I like having easy access to my &lt;code&gt; .bash_profile &lt;/code&gt;, so it makes sense for me to alias the following:
&lt;script src=&quot;https://gist.github.com/BenBrostoff/e455104c9d487cfdbb11.js&quot;&gt;&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I admit a reasonable knock against aliasing is that when you move over to another machine, you’re a fish out of water. However, I’d like to believe if I take a few minutes every month to review my &lt;code&gt; .bash_profile &lt;/code&gt;, I can partially mitigate this risk.&lt;/p&gt;
</description>
        <pubDate>Sun, 23 Aug 2015 00:00:00 -0400</pubDate>
        <link>http://benbrostoff.github.io//2015/08/23/Automating-Via-Alias-And-Bash/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2015/08/23/Automating-Via-Alias-And-Bash/</guid>
      </item>
    
      <item>
        <title>Languages and Opinions</title>
        <description>&lt;p&gt;I find a lot of my preferences often are based on what I’ve been exposed to. If given a choice, I’d prefer to program something in Python rather than in Haskell because I have many, many times more hours of experience in the former. &lt;/p&gt;

&lt;p&gt;The risk of this inevitable correlation between preferences and exposure is that prefences and norms begin to overlap with eachother. An example - while working in Ruby the other day, something along the lines of the following happened:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/BenBrostoff/7ef3a4056787142b1265.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;I must admit my first reaction here was annoyance with Ruby. This annoyance was a reaction to feeling wronged by the &lt;code&gt;NameError&lt;/code&gt; in front of me. As consolation, I needed to prove the same code would execute in Python, which it did:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/BenBrostoff/5e261bd7317391c69e74.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Differences in languages like this one seem to me to be the beginnings of endlessly long programming language debates that are always normative in nature - “How should things be?” These debates are where my own preferences are sometimes revealed as my desired norms, and, by extension, my preferred norms are what I have been exposed to. Admittedly, sometimes my preferred norms are a reaction &lt;em&gt;against&lt;/em&gt; what I have been exposed to (perhaps this is more common in general, considering all the complaining about the shortcomings of, say, JavaScript). &lt;/p&gt;

&lt;p&gt;In the above example, there are strong debates on both sides for whether languages should allow local variables declared outside the body of a method to have scope that extends inside the body of a method. Language designers have thought far more about this debate than I have. I am merely a language consumer.&lt;/p&gt;

&lt;p&gt;In a way, until we create tools ourselves, our opinions on existing tools are limited by what we have and have not been exposed to. I can easily see a scenario where, had I needed to fix a troublesome bug related to a scoping issue, I would be equally annoyed that Python did not raise an error on the above example. &lt;/p&gt;

&lt;p&gt;Thus, it seems to me the best way to avoid forming malformed opinions is to gain exposure and make tools.   &lt;/p&gt;
</description>
        <pubDate>Sat, 18 Apr 2015 00:00:00 -0400</pubDate>
        <link>http://benbrostoff.github.io//2015/04/18/Languages/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2015/04/18/Languages/</guid>
      </item>
    
      <item>
        <title>Resolutions by Type</title>
        <description>&lt;p&gt;I posted thoughts on &lt;a href=&quot;http://benbrostoff.github.io/2014/12/28/Resolution/&quot; target=&quot;_blank&quot;&gt; improving as a programmer &lt;/a&gt; in 2015 a few days back, but thought I would post my complete resolutions so I can reference them come 12/31/2015. &lt;a href=&quot;http://blog.fogus.me/&quot; target=&quot;_blank&quot;&gt;Fogus&lt;/a&gt; has an awesome tradition on his blog of posting “The best things and stuff of [Year]” going back to 2010, so I think it would be cool to emulate that idea with resolutions and reflections on whether those resolutions were met or not. Here we go, by type: &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Attitude&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Keep this quote in mind every day. From Marcus Aurelius in &lt;a href=&quot;http://www.amazon.com/Meditations-New-Translation-Marcus-Aurelius/dp/0812968255&quot; target=&quot;_blank&quot;&gt;Meditations&lt;/a&gt;, Book 2.5:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
Concentrate every minute... on doing what&#39;s in front of you with precise and genuine seriousness, tenderly, willingly, with justice. And on freeing yourself from all other distractions. Yes, you can - if you do everything as if it were the last thing you were doing in your life, and stop being aimless, stop letting your emotions override what your mind tells you, stop being hypocritical, self-centered, irritable. You see how few things you have to do to live a satisfying and relevant life?
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Craft&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Program every day&lt;/li&gt;
  &lt;li&gt;Blog every month with a quality post&lt;/li&gt;
  &lt;li&gt;Read cover to cover &lt;a href=&quot;http://www.amazon.com/Understanding-Computation-Machines-Impossible-Programs/dp/1449329276&quot; target=&quot;_blank&quot;&gt;Understanding Computation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Study Haskell and Lisp in concert on weekends, under the theory that &lt;a href=&quot;http://lemire.me/blog/archives/2014/12/30/how-to-learn-efficiently/&quot; target=&quot;_blank&quot;&gt;interleaved study trumps mass study&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Review &lt;a href=&quot;https://github.com/thomasahle/sunfish&quot; target=&quot;_blank&quot;&gt;Sunfish&lt;/a&gt; in its entirety and blog on it&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Fitness (Body and Mind)&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Eradicate sugar intake, sans social occassions &lt;/li&gt;
  &lt;li&gt;20 minutes+ of physical activity, 5+ days a week&lt;/li&gt;
  &lt;li&gt;Meditate 5+ minutes every day  &lt;/li&gt;
  &lt;li&gt;Read 20+ minutes every day&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Other&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Memorize a 52 card deck in &amp;lt; 5 minutes&lt;/li&gt;
  &lt;li&gt;Complete the Rubik’s cube in &amp;lt; 5 minutes&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 01 Jan 2015 00:00:00 -0500</pubDate>
        <link>http://benbrostoff.github.io//2015/01/01/Resolutions-by-Type/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2015/01/01/Resolutions-by-Type/</guid>
      </item>
    
      <item>
        <title>Resolution</title>
        <description>&lt;p&gt;&lt;em&gt;Update (4/5/2015) - Matt Might has a fantastic article on his blog on this same subject. &lt;a href=&quot;http://matt.might.net/articles/programmers-resolutions/&quot; target=&quot;_blank&quot;&gt; Here it is &lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;My top New Year’s Resolution for 2015 is the same as it was for 2014: improve as a programmer. How to improve is a question I feel I’m continually exploring. I thought it would be useful to reflect on some techniques for improving that worked well for me this year, as well as techniques I would like to implement next year.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Programming (almost) every day&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;John Resig has an &lt;a href=&quot;http://ejohn.org/blog/write-code-every-day/&quot; target=&quot;_blank&quot;&gt; excellent post on this topic &lt;/a&gt; which I found myself referring to a number of times over the last year. I find the main benefit of this practice for me has been to (i) familiarize myself with languages and frameworks via repetition and (ii) inspire good habits via repetition (alternatively, I’m sure I’ve also inspired some bad habits). I don’t think (i) deserves much explanation - to me, this familiarization is tantamount to learning the controls of a video game after a few days of playing. &lt;/p&gt;

&lt;p&gt;Once this familiarity is engrained, you spend less time fumbling around levels and more time learning strategy and the nuances of gameplay. I like (ii) because to a degree it happens naturally, just like (i). The more code I read from programmers I admire, the more I intuitively try to emulate their techniques and habits.&lt;/p&gt;

&lt;p&gt;The habit I feel has developed for me the most from (ii) is to try to refactor my own code by making it less repetitive. One of my most common personal refactors no doubt is to abstract similar blocks of code into one function I then call twice or more. &lt;/p&gt;

&lt;p&gt;For instance, a &amp;lt;a href=”https://github.com/BenBrostoff/EveryColor-Visual” target=_blank”&amp;gt; side project &amp;lt;/a&amp;gt; I’ve been working on that involved animating dots called for me to assign a random horizontal and vertical direction for each dot upon page load. My first shot at this involved me writing the same instructions for each direction: &lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/BenBrostoff/6475c1547194c46870e9.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;I saw this code and remember feeling annoyed enough that I had to refactor immediately:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/BenBrostoff/24cb8ea606dd3f2df11e.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;I don’t know that I would have been so bothered as to be compelled to make this change back in January. I believe reading and writing code on a regular basis has resulted in increased standards for code quality on my personal projecs; I am hopeful that 2015 will bring more of this effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Working on mini-projects to learn new technologies&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I first heard this technique really explained well by Dave Hoover in his book &lt;a href=&quot;http://www.amazon.com/Apprenticeship-Patterns-Guidance-Aspiring-Craftsman/dp/0596518382&quot; target=&quot;_blank&quot;&gt;Apprenticeship Patterns&lt;/a&gt; - he calls it building “breakable toys”. It’s also suggested by a number of the elite programmers Peter Seibel interviews in his book &lt;a href=&quot;http://www.amazon.com/Coders-Work-Reflections-Craft-Programming/dp/1430219483&quot; target=&quot;_blank&quot;&gt;Coders at Work&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;The chief advantage of this technique is that it allows for learning in a zero-pressure environment (that might also be its chief disadvantage). Without the requirement of delivering deadline-bound results, I find I’m more apt to explore the why and how of technologies as opposed to focusing on implementation of them. I’ve used this technique effectively to learn a little bit about building &lt;a href=&quot;https://github.com/BenBrostoff/BenTrackerGem&quot; target=&quot;_blank&quot;&gt; Ruby gems &lt;/a&gt;, &lt;a href=&quot;https://github.com/BenBrostoff/Angular-JS-Lightning-Talk&quot; target=&quot;_blank&quot;&gt; using Angular.js &lt;/a&gt; and &lt;a href=&quot;http://benbrostoff.github.io/2014/08/26/querying-in-mongo-with-node/&quot; target=&quot;blank&quot;&gt; working with MongoDB &lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My favorite ongoing mini-project this year has been my work with the Raspberry Pi I received for my birthday. &lt;a href=&quot;http://benbrostoff.github.io/2014/12/13/The-Internet-is-Awesome/&quot; target=&quot;_blank&quot;&gt; I wrote about it here&lt;/a&gt;, but in summary, the Pi has continually delivered education for me on the relationship between hardware and software.  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Learning a new language to explore new concepts&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt; LISP has been jokingly described as &quot;the most intelligent way to misuse a computer&quot;. I think that description a great compliment because it transmits the full flavor of liberation: it has assisted a number of our most gifted fellow humans in thinking previously impossible thoughts. 
&lt;p&gt;&lt;/p&gt;
&lt;center&gt; - Edsger Dijkstra&lt;/center&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://zencephalon.com/index&quot; target=&quot;_blank&quot;&gt; A great teacher of mine &lt;/a&gt; once told me that our thoughts are bound by the languages that we speak. My programming thoughts in 2014 were mostly restricted to Ruby, Python and JavaScript - all dynamically typed, object-oriented languages. I want to amend that in 2015 by learning a statically-typed language, a functional language (Haskell is the early candidate) and Lisp (because of the above quote and the fact that Paul Graham inspired me to start programming in the first place). &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. Reading about your predecessors to motivate you&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I recently finished Walter Isaacson’s &lt;a href=&quot;http://www.amazon.com/dp/147670869X&quot; target=&quot;_blank&quot;&gt;The Innovators&lt;/a&gt; and am in the process of reading &lt;a href=&quot;http://www.amazon.com/Hackers-Computer-Revolution-Anniversary-Edition/dp/1449388396&quot; target=&quot;_blank&quot;&gt; Hackers&lt;/a&gt; by Steven Levy. The engineers who laid the foundation for modern computing are giants, and it has humbled me to read about them and then use the software they wrote on a regular basis. The impulse to complain about certain tools (technology X can’t do Y) is more than negated when I consider the amount of ingenuity and effort it took to construct the tools in the first place (and the tools that built the tools, and so on). Complaints should always be replaced with attempts at solutions; to me, this seems to be a central part of the engineer ethic. &lt;/p&gt;

&lt;p&gt;More than anything else, learning more about my predecessors motivates me to want to improve the existing body of knowledge we have about computer science and build better tools for future programmers to work with. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. Answering the “What am I trying to accomplish right now?” question&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Too often in 2014 I found myself traveling down a rabbit hole when trying to implement a new feature on a project, debug a problem, or learn how to do something new. I’m sure this experience is common among developers - you enter a question or error message into Google, begin reading a Stack Overflow post, run over to a GitHub issue page, copy and paste some code, get a new error message, and then rinse and repeat. After a couple iterations, you’re so far removed from the original task that you forget what exactly it is you’re trying to do. &lt;/p&gt;

&lt;p&gt;In my opinion, this is the biggest problem with “Google-driven” development. Without some consciousness of your intent and original goals, you rely on the advice of others while implicity assuming they know the exact nature of your problem. In 2014, I was too quick to keep googling without doing important intermittent analyses on what I looking for. In 2015, I’d like to know what I’m trying to accomplish before traversing the interwebs for solutions.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. Combating Imposter Syndrome with improvement&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Much has been written on Imposter Syndrome, &lt;a href=&quot;http://blog.42floors.com/imposter-syndrome/&quot; target=&quot;_blank&quot;&gt; including this post &lt;/a&gt; I particulary enjoyed from Jason Freedman. As someone who began programming in college and attended a non-college / university program to gain a better background in web development, I find it tempting to compare myself against life-long programmers and feel like an imposter. &lt;/p&gt;

&lt;p&gt;While I do think as a collective society we have to acknowledge that programmers who started at a young age have certain inherent advantages over people like myself, starting “late” by no means should disqualify anyone from being a value-add in whatever profession they display interest in. All I can do at this point is attempt to improve as best I can and use my time wisely to become a better programmer. &lt;/p&gt;

&lt;p&gt;And indeed, that’s my top New Year’s resolution for 2015. &lt;/p&gt;
</description>
        <pubDate>Sun, 28 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://benbrostoff.github.io//2014/12/28/Resolution/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2014/12/28/Resolution/</guid>
      </item>
    
      <item>
        <title>The Internet Is Awesome</title>
        <description>&lt;p&gt;I spent the great majority of this weekend messing around with a Raspberry Pi I received for my birthday from my dad. Besides being a leading candidate for best present I have ever received, the Pi led me to three great epiphanies:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The internet has exponentially expanded our ability to work alone and without friction costs on projects we enjoy, which in turn has led us to new projects we otherwise never would have taken on&lt;/li&gt;
  &lt;li&gt;Contributing to the internet is as enjoyable as receiving from it, which encourages people to both consume and create knowledge&lt;/li&gt;
  &lt;li&gt;All of this bodes well for a knowledge economy&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I think (1) was the most obvious realization for me, so I’ll start there. I am absolutely sure the Rasberry Pi is a project I would have abandoned as a child. I know I would have abandoned it not out of a lack of tenacity or curiousity - I know I would not have been able to find out what to do if I were stuck. To be clear, the Rasberry Pi is meant for children, and the projects I worked on this weekend are embarrassingly kid-oriented (lighting up LED bulbs). Yet, do-it-yourself assembly kits for kids require instruction (think &lt;a href=&quot;http://www.amazon.com/Schylling-Sea-Monkeys-Ocean-Zoo/dp/B001CBZXEE&quot; target=&quot;_blank&quot;&gt; Sea Monkeys&lt;/a&gt;) that might not necessarily be obvious to adults.&lt;/p&gt;

&lt;p&gt;Most every step of the way this weekend on the Raspberry Pi I had no idea what to do and was just referring to some online tutorial or YouTube video (among other things, I learned the UK seems to be the largest producer of Pi-oriented content, perhaps because the Pi was invented there). Parsing through good and bad stuff was fairly easy, and even YouTube comments served as a means of curating material for me:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lh5.googleusercontent.com/-b5hljcg0F9g/VIzfI0f-vCI/AAAAAAAAAZU/riSmAtr7-n4/w621-h515-no/Screen%2BShot%2B2014-12-13%2Bat%2B7.50.52%2BPM.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I know of no other medium so good at simultaneously offering humor and useful information. &lt;/p&gt;

&lt;p&gt;That brings me to (2). I thank the internet this weekend for giving me the opportunity to SSH into my Pi from my laptop, light up LEDs and not look like an idiot when working with Vi. All these things no doubt better my quality of life, which is why I feel strongly about giving back to the internet through developing software and general knowledge sharing (this blog, I hope). &lt;/p&gt;

&lt;p&gt;And finally, (3). The fact that the Raspberry Pi is aimed at children but that an entire knowledge economy among adults has formed (and continues to grow) makes me optimistic about the future of Planet Earth. In addition to enriching our experience and pushing us to produce good content as knowledge-sharers, the internet leads to wholly unpredictable innovation. When the Pi’s inventors built it to raise computer science interest, I’m not sure they could have envisoned adults &lt;a href=&quot;http://jack.minardi.org/raspberry_pi/make-an-internet-controlled-lamp-with-a-raspberry-pi-and-flask/&quot; target=&quot;_blank&quot;&gt; building web applications to control lights &lt;/a&gt; with a back-end framework developed in 2010. &lt;/p&gt;

&lt;p&gt;The internet has a way of inspiring creative initiatives. As Jack Minardi notes in his blog post linked above:&lt;/p&gt;

&lt;blockquote&gt;
&quot;NOTE: I am not a Flask or web design expert, so I might not be doing things the correct way. But it wouldn&#39;t be hacking if we knew what we was doing all the time, would it?&quot;
&lt;/blockquote&gt;

&lt;p&gt;I believe people feel initiative to contribute on the internet and are not burdened by fear of being wrong (a burden that so often rears its ugly in corporate culture and academia). The environment people have created online is conducive to exponential knowledge growth, which is overwhelmingly positive in any knowledge economy. The internet is awesome. I’m excited and proud to be a part of it.&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Dec 2014 00:00:00 -0500</pubDate>
        <link>http://benbrostoff.github.io//2014/12/13/The-Internet-is-Awesome/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2014/12/13/The-Internet-is-Awesome/</guid>
      </item>
    
      <item>
        <title>Abstraction</title>
        <description>&lt;blockquote&gt; If you interview somebody coming out of computer science right now, they don&#39;t understand the underyling computing at all. It&#39;s really, really scary how abstract they are from what a computer is or even the theory of computing. They just don&#39;t understand it. &lt;/blockquote&gt;

&lt;blockquote&gt;Computer science is coming into its middle age. It&#39;s turning into a commodity. People don&#39;t know about Carnot cycles for refrigerators, yet they buy refrigerators. It&#39;s happening in computing too. Who knows about compilers? They buy computers to play games and balance their checkbooks. &lt;/blockquote&gt;

&lt;center&gt; - Ken Thompson, from &lt;a href=&quot;http://www.amazon.com/Coders-Work-Reflections-Craft-Programming/dp/1430219483&quot; target=&quot;_blank&quot;&gt;&lt;i&gt;Coders at Work&lt;/i&gt;&lt;/a&gt; and &lt;a href=&quot;http://genius.cat-v.org/ken-thompson/interviews/unix-and-beyond&quot; target=&quot;_blank&quot;&gt;&lt;i&gt;Computer&lt;/i&gt;&lt;/a&gt; magazine, respectively &lt;/center&gt;

&lt;p&gt;The knock against junior programmers for several decades now seems to be that they don’t sufficiently understand the layers and layers upon which the tools they use are built. From a senior programmer’s perspective, junior programmers are, among other reasons, a liability because they lack strong understanding of &lt;i&gt;how&lt;/i&gt; their code works. This criticism is fair because poor understanding generally translates into an inability to debug code or optimize performance or do any number of things. &lt;/p&gt;

&lt;p&gt;This issue seems especially relevant now because of the preponderence of coding bootcamps in New York churning out “Rails developers”, of which I suppose I am one. I put Rails developers in quotes because I believe it’s ridiculous to characterize anyone as a particular type of programmer when they have less than a year of experience and have never worked in a professional setting (I’d honestly just prefer to be characterized as a junior developer). &lt;/p&gt;

&lt;p&gt;“Rails developers” in particular are viewed by some as liabilities because the very framework that governs their productivity champions abstraction and (it seems) seeks to become increasingly more abstracted. I previously wrote a little bit about &lt;a href=&quot;http://benbrostoff.github.io/2014/05/28/magiccurtain/&quot; target=&quot;_blank&quot;&gt; my own discomfort&lt;/a&gt; with these abstractions. &lt;/p&gt;

&lt;p&gt;Ironically, the success of Rails in enterprise settings also to me seems founded upon abstraction, as abstraction (at its most basic, all the &lt;code&gt;rails g&lt;/code&gt; commands) boosts productivity, where productivity is a nebulous concept defined by product managers. I would venture to guess many bootcamps believe Rails is the most effective way for junior programmers to become value-adds in their future workplaces.&lt;/p&gt;

&lt;p&gt;I don’t believe any discussion about productivity can be had without also discussing fragility. If productivity is measured as simply the number of lines of code someone writes, it’s easy to imagine a scenario wherein someone is massively productive, but the codebase is also incredibly fragile (the same situation occurs where productivity is a measure of features added / time). &lt;/p&gt;

&lt;p&gt;A familiar story in tech start-ups is the web application thrown together in two weeks that initially took off but then could not scale because of the technical debt accrued during the two-week sprint. Perhaps as familiar are all the stories of Rails applications that could not scale. &lt;/p&gt;

&lt;p&gt;Alternatively, there are scores of stories about software engineers trying to do something concisely and infinitely scaleable in Language X and taking months to launch a simple product as a result. There is an unknown relationship between productivity and fragility, although it’s certainly not linear. Importantly, I think the idea of abstraction is at the heart of this relationship. More abstracted tools lead to greater productivity but also greater fragility.&lt;/p&gt;

&lt;p&gt;I do not believe the benefits and dangers of abstraction are any less great in other industries than they are in software. I’m currently reading Robert Gates’ memoirs, &lt;a href=&quot;http://www.amazon.com/Duty-Memoirs-Secretary-at-War/dp/0307959473&quot; target=&quot;_blank&quot;&gt;Duty&lt;/a&gt;, and my main takeaway thus far is how much the Pentagon and Commander in Chief rely on abstraction to speed up processes. Based on my reading of Gates, extremely complex issues (how many dollars to budget for new military technology Y or Z; how many troops to allocate and reallocate based on US strategic interests; etc.) are increasingly simplified as they’re pushed up the chain. &lt;/p&gt;

&lt;p&gt;By the time the Commander in Chief rules on a particular issue, it seems to have literally been simplified to an abstract from an original thousand plus page memo. The fragility-productivity tradeoff I see as one of the major themes of the book, as the decisions Gates regrets can often be attributed to a lack of information, or rather, he was too abstracted out to understand the consequences of these decisions.&lt;/p&gt;

&lt;p&gt;Gates seems actively aware of this tradeoff and frequently dives deeper into issues where he believes abstraction could do him a disservice. He professes to being extremely confused toward the end of Bush 43’s second term as to whether progress was being made in Afghanistan; his commanders on the field claim yes, while the analysts in Washington claim no. Whereas some internal abstraction laws might have sped up Afghanistan-related decisions (trust the Washington guys here; trust the military here), Gates is content to devote resources to resolving the disagreements and studying each side at length to reconcile the opinions he’s receiving.&lt;/p&gt;

&lt;p&gt;At a much less consequential level, software engineers have to make decisions like this every day. In a Rails setting, for instance, it seems extremely common to have a situation where a certain gem does the gist of what you’re looking for, but doesn’t quite accomplish the task. I have no doubt spent countless hours reading gem documentation where it would have been more productive to just write code that replicates some of the gem’s basic functionality and adds the specifications I want. &lt;/p&gt;

&lt;p&gt;On the other end of the spectrum, I’ve spent countless hours writing code when there exists a gem that houses what I was going for and does it in a cleaner way. That said, I prefer this experience to the former, as recreating the wheel at least teaches you how to build a wheel.&lt;/p&gt;

&lt;p&gt;The decision to deep dive or to trust abstraction in some respects boils down to (i) our view of the risk associated with relying on other people or tools built by other people and, perhaps more importantly, (ii) the risk of not learning the ground that our abstractions stand on. I believe (i) to be a reality of life in general; we are inherently forced to rely on other people and tools to be productive members of society. The risk of (i) can in part be avoided by good due diligence.&lt;/p&gt;

&lt;p&gt;I consider (ii), however, critically important and that bending on (ii) is tantamount to bending on long-term quality and risk-management. As a junior programmer, I know well that (ii) will govern whether senior engineers trust me and are comfortable with my work. I believe being able to trace the ladder of abstraction, whether in software or in life, can enhance all decisions by building in logic and reason where it might not have existed. Furthermore, I think a strong knowledge of where certain tools and assumptions come from can inform the abstraction v. productivity tradeoff, leading to time-saved in some areas and time well-spent in other areas.&lt;/p&gt;

&lt;p&gt;I speak as someone extremely early in my quest to build this knowledge, and hope that my own abstactions have not affected my intended meaning. In the words of Guy Steele in Peter Seibel’s &lt;a href=&quot;http://www.amazon.com/Coders-Work-Reflections-Craft-Programming/dp/1430219483/&quot; target=&quot;_blank&quot;&gt;&lt;i&gt;Coders at Work&lt;/i&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt; Something I worry about a lot when I write, that I&#39;m less worried about with a computer, is about the ways in which English is ambiguous. I&#39;m constantly worried about the ways in which the reader might misinterpret what I&#39;ve written. &lt;/blockquote&gt;
&lt;p&gt;. &lt;/p&gt;

</description>
        <pubDate>Tue, 23 Sep 2014 00:00:00 -0400</pubDate>
        <link>http://benbrostoff.github.io//2014/09/23/Abstraction/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2014/09/23/Abstraction/</guid>
      </item>
    
      <item>
        <title>Callbacks & Closures in JS with Brad Dayley</title>
        <description>&lt;p&gt;I recently purchased Brad Dayley’s book on the MEAN stack entitled &lt;a href=&quot;http://www.amazon.com/Node-js-MongoDB-AngularJS-Development-Developers/dp/0321995783&quot; target=&quot;_blank&quot;&gt; Node.js, MongoDB and AngularJS Web Development &lt;/a&gt; (there’s also a section on Express, for those wondering about the E).The book is fantastic and Dayley provides a &lt;a href=&quot;https://github.com/bwdbooks/nodejs-mongodb-angularjs-web-development&quot; target=&quot;_blank&quot;&gt; GitHub repo &lt;/a&gt; with the code for all the exercises covered in the book.&lt;/p&gt;

&lt;p&gt;I have always struggled with the idea of callbacks and closures in JavaScript, and fortunately, Dayley is up to the task of walking through them. Callbacks and closures are especially important in Node.js, which, unlike most web-servers (when Node is used as a web-server), is single-threaded and event driven. To use an extended analogy provided in the book, if Node were the host of a party, it would speak to all guests individually and remember to come back to certain conversations after it had attended to other conversations, whereas most web-servers would just chat with everyone at one time. Node’s ability to push events into the background and return to them can act as a powerful advantage.   &lt;/p&gt;

&lt;p&gt;The exercise Dayley uses to demonstrate is one that relies on the &lt;a href=&quot;http://nodejs.org/api/process.html#process_process_nexttick_callback&quot; target=&quot;_blank&quot;&gt; &lt;code&gt;process.nextTick()&lt;/code&gt; &lt;/a&gt; function native to Node. The function takes a callback and tells Node to execute the function on the next event loop. To return to the party analogy, &lt;code&gt;process.nextTick()&lt;/code&gt; schedules conversations with guests only after “earlier”” scheduled conversations have been attended to. I have tried to visually depict these loops in the console in the code below (which is almost wholly copied from Dayley’s &lt;a href=&quot;https://github.com/bwdbooks/nodejs-mongodb-angularjs-web-development/blob/master/ch04/callback_closure.js&quot; target=&quot;_blank&quot;&gt; exercise &lt;/a&gt;, with some minor alterations):&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/BenBrostoff/e4e619df6d4ecbb2f436.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;The code above iterates twice through an array of three cars and logs the cars to the console. The key difference here is &lt;i&gt; when &lt;/i&gt; the execution of the function &lt;code&gt;logCar()&lt;/code&gt; nested in the loop in 11-17 occurs, versus the function &lt;code&gt;wrapperFn()&lt;/code&gt; nested in the loop in 19-28. &lt;code&gt;wrapperFn()&lt;/code&gt; calls &lt;code&gt;logCar()&lt;/code&gt; and “wraps” around it - hence the name. &lt;/p&gt;

&lt;p&gt;The wrapper function here makes all the difference. The callback in &lt;code&gt;logCar()&lt;/code&gt; is destined not to execute until the second event loop in the program because it is wrapped in the aforementioned &lt;code&gt;process.nextTick()&lt;/code&gt;. Thus, “first loop” events, like the for loops that begin in 11 and 19,  will occur prior to the callback. &lt;/p&gt;

&lt;p&gt;Because the execution of the callback must occur after the for loops are complete, the only way all the cars can get logged to the console is if the variables passed in as parameters each uniquely represent the three cars. &lt;/p&gt;

&lt;p&gt;In 11-17, the &lt;code&gt;message&lt;/code&gt; parameter &lt;code&gt;logCar()&lt;/code&gt; takes on 13 will appear in the anonymous function always as the final element in the car array: Bugatti. The variable &lt;code&gt;message&lt;/code&gt; serving as the parameter in &lt;code&gt;logCar()&lt;/code&gt; is changing each time through the loop, and by the time the anonymous function uses it on the second event loop, the variable is equal to the final element in the array. In closure terms, &lt;code&gt;logCar()&lt;/code&gt; is the parent function of the anonymous function, and the parameter it passes to the anonymous function changes twice; however, since the callback executes on the second event loop, it is doomed to grab the parameter after the final iteration.&lt;/p&gt;

&lt;p&gt;In contrast, the function &lt;code&gt;wrapperFn()&lt;/code&gt; in 21 does not let cars race by (excuse the pun), instead grabbing them and passing them along to its child functions in 27 when &lt;code&gt;wrapperFn()&lt;/code&gt; is called. As you can see visually via “PARAMETER PASSED 2: “, the message variable is being caught on the first event loop and saved in memory for the second event loop. &lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;https://lh5.googleusercontent.com/-VQSw0iVAE1w/VAyfjUURN5I/AAAAAAAAAXY/0OA4CB01Q_8/w282-h458-no/Screen%2BShot%2B2014-09-07%2Bat%2B2.09.07%2BPM.png&quot; alt=&quot;callback_clos_output&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;The value of closures in this exercise was to close off certain variables from change and give the callback function the information it needed. Because Node (and JavaScript in general) relies heavily on events occurring at different points in time, closures are key to making sure the passage of time will not get in the way of what the programmer intended (at least the way I see it).&lt;/p&gt;

&lt;p&gt;Additionally, I realized while doing this exercise the importance of using closures in conjunction with callbacks to grab information from AJAX requests to bring such information to the client-side. As AJAX requests by definition occur asynchronously, they represent a perfect situation for implementing closures and callbacks.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/bsusensjackson/&quot; target=&quot;_blank&quot;&gt; Brendan Susens-Jackson&lt;/a&gt;, who I worked with on a side project called &lt;a href=&quot;http://ready-reader.herokuapp.com/&quot; target=&quot;_blank&quot;&gt;ReadyReader&lt;/a&gt;, originally explained this idea to me and put it to work on our application. The source code can be found &lt;a href=&quot;https://github.com/woodchucks-2014/ReadyReader&quot;&gt; here&lt;/a&gt;. Brendan helped edit this post, so hats off to him :-).  &lt;/p&gt;

</description>
        <pubDate>Sun, 07 Sep 2014 00:00:00 -0400</pubDate>
        <link>http://benbrostoff.github.io//2014/09/07/Closures-in-JS-from-Brad-Dayley/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2014/09/07/Closures-in-JS-from-Brad-Dayley/</guid>
      </item>
    
  </channel>
</rss>