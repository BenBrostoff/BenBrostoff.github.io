<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ben Brostoff</title>
    <description></description>
    <link>http://benbrostoff.github.io/</link>
    <atom:link href="http://benbrostoff.github.io//feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Migration to Jekyll</title>
        <description>&lt;p&gt;There are few things in life I dislike more than repetitive processes that could be automated where I learn very little (recall I&amp;rsquo;m a former investment banking analyst). My initial construction of a personal blog met this criteria. &lt;/p&gt;

&lt;p&gt;I was working with a bunch of HTML and CSS files I had coded myself. Every blog post was an individual HTML page - if I wanted to make a change to the header, footer or general layout of my site, I had no choice but to change every single page. One can imagine how annoying this process became as my blog expanded. There were also a host of smaller issues that bothered me: &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I had to manually type in the dates and times of my posts&lt;/li&gt;
&lt;li&gt;My site looked terrible on mobile and tablet devices&lt;/li&gt;
&lt;li&gt;I was not pleased with the hierarchy of folders and each file&amp;rsquo;s place in the hierarchy I made up. Yet, if I wanted to change the set-up, I would have to relink every HTML page accordingly.&lt;/li&gt;
&lt;li&gt;I was spending more time on layout decisions (the classic border, padding, margin debacle) and CSS shenanigans (color schemes, hover links, shapes, etc.) than I was on writing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Constructing quality blog posts (mini-essays in some cases) is a labor of love for me and something I&amp;rsquo;ve done since I learned to write. Pre-internet, I was journaling obsessively and documenting all the inane events interesting to a sports-obsessed grade schooler (if you want to hear about Antoine Walker&amp;rsquo;s second go-around with the Celtics wherein he changed his number to 88 to accomodate Big Al Jefferson, by all means, swing by). I have experience in writing and editing my own writing (as well as others&amp;#39; writing) - I wrote for my local newspaper in highschool and was the Editorial Pages Editor and a &lt;a href=&quot;https://www.dukechronicle.com/staff/ben-brostoff/articles&quot;&gt;columnist for three years for the Duke Chronicle&lt;/a&gt;. I&amp;rsquo;m very comfortable writing - I&amp;rsquo;m less comfortable managing an entire website.&lt;/p&gt;

&lt;p&gt;Enter &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;. Jekyll is a simple Ruby gem you install via your Terminal. By creating a new project through Jekyll, you get a working template with a ready-to-go setup that&amp;rsquo;s easily customizable. The Jekyll new project folder reminds me a bit of a new Ruby on the Rails project in that you have a nicely organized hierarchy that lends itself to easy changes. Below is a screenshot of a new Jekyll project on my desktop: &lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src = &quot;https://lh3.googleusercontent.com/-JP5YbBMsNQg/U4NVliccwQI/AAAAAAAAALs/nEwpt9NXTaE/w215-h152-no/jekconfig.png&quot; alt= &quot;jekyll&quot;&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;From there, it&amp;rsquo;s easy to fool around with config.yml, layouts and css to change your blog as you please. A massive amount of Jekyll work is posted on Github, so it&amp;rsquo;s also easy to leverage off the work of your Jekyll predecessors. I cloned the &lt;a href=&quot;https://github.com/muan/scribble&quot;&gt;Scribble theme&lt;/a&gt; created by &lt;a href=&quot;https://github.com/muan&quot;&gt;Mu-An Chiou&lt;/a&gt; from GitHub and customized it a bit - thanks again Mu-An. &lt;/p&gt;

&lt;p&gt;Since I migrated to Jekyll, I&amp;rsquo;ve found myself spending considerably less time on blog design and layout and considerably more time on writing. I&amp;rsquo;m biased, but I feel the quality of my writing on this blog has in part improved because of Jekyll.&lt;/p&gt;
</description>
        <pubDate>Mon, 26 May 2014 00:00:00 -0400</pubDate>
        <link>http://benbrostoff.github.io//2014/05/26/general-jekyll/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2014/05/26/general-jekyll/</guid>
      </item>
    
      <item>
        <title>Static v. Dynamic Typing</title>
        <description>&lt;p&gt;This quote from Brendan Eich (creator of JavaScript) caught my eye while reading Peter Seibel&amp;rsquo;s &lt;a href=&quot;http://www.amazon.com/Coders-Work-Reflections-Craft-Programming/dp/1430219483&quot;&gt;&lt;em&gt;Coders at Work&lt;/em&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Dynamic languages became popular because people can actually rapidly prototype&amp;hellip; Then maybe ater on, if they have a language that can support it, or if they&amp;rsquo;re recoding in a static language, they can write down the types. That was one of the reasons why in JavaScript we were intereted in optional typing, and we still are, though it&amp;rsquo;s controversial in the committee. There&amp;rsquo;s still a strong chance we&amp;rsquo;ll get some kind of hybrid type system into a future version of JavaScript.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I neglected to note &lt;a href=&quot;http://benbrostoff.github.io/2014/04/20/technical-week-3/&quot;&gt;in an earlier post on criticisms of JavaScript&lt;/a&gt; that many programmers object to the language only catching type errors at runtime as opposed to compile time. In JavaScript, as in Ruby, Python, and other dynamically typed languages, variables are interpreted at runtime and can be changed (e.g. reassigned) as the program runs sequentially. &lt;/p&gt;

&lt;p&gt;Consequently, &lt;strong&gt;dynamic languages&lt;/strong&gt; make no demands of the programmer at compilation time and use inference to define types at runtime. This inference is also referred to as &lt;strong&gt;duck typing&lt;/strong&gt; - objects that look like and act like type &amp;ldquo;duck&amp;rdquo; are assumed to be of type &amp;ldquo;duck&amp;rdquo; at runtime. As Eich notes in the quote above, such languages allow for faster prototyping. &lt;/p&gt;

&lt;p&gt;In contrast, &lt;strong&gt;static languages&lt;/strong&gt; force the programmer to define types at compilation time and are simultaneously restrictive to productivity and a boon to error-free code. Java is the posterchild of static languages, and, to a lesser extent, C and C++ are known for being statically typed (unlike Java, though, types are not as rigidly enforced throughout the program in runtime). &lt;/p&gt;

&lt;p&gt;The debate around different different types of typing interestingly really seems to be about different types of programmers. &amp;ldquo;Good&amp;rdquo; progammers can be trusted with dynamically typed languages because they pay attention to types in the first place and write good tests. Conversely, &amp;ldquo;bad&amp;rdquo; programmers cannot be trusted to to not make type errors and need static typing to keep them in check. &lt;/p&gt;

&lt;p&gt;To a proponent of statically typed languages, any efficiency advantage to be had from dynamically typed languages is more than negated by the silly type errors that result from the lack of checks native to dynamic languages at compile time.&lt;/p&gt;

&lt;p&gt;To a proponent of dynamically typed languages, statically typed languages are unnecessarily slow and take x + y lines of code to accomplish what could be done in x lines of code in a dynamically typed language.&lt;/p&gt;

&lt;p&gt;This last point registers significantly with me, as during my brief time in an intro Java class, I remember being extremely annoyed with the class hierachies and the inability to code &amp;ldquo;outside&amp;rdquo; of a class. Just the build up to writing something useful - &lt;strong&gt;public static Main&lt;/strong&gt; and &lt;strong&gt;public static void Main (String args[])&lt;/strong&gt; and what not - was a constant thorn in my side. In contrast, Ruby gives the programmer freedom to call whatever method on whatever object and deal with the consequences (if any) at runtime. &lt;/p&gt;

&lt;p&gt;I understand any programmer over the age of 30 is probably reading this and shaking their head. Older languages no doubt were less lenient on type definition and built better programmers as a result. Anyone who argues that today&amp;rsquo;s programmers are building bad habits as a result of new dynamically typed languages is likely correct. &lt;/p&gt;

&lt;p&gt;However, the solution to the new generation of programmers having bad habits is not to have them stop using dynamic languages entirely - it&amp;rsquo;s to change the education system. Even if a language is dynamically typed, programmers can learn to keep track of their types by explicity defining them in the code (if the language allows it), using well written tests and &lt;a href=&quot;http://harrypotter.wikia.com/wiki/Alastor_Moody&quot;&gt;constant vigilance&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;Now, if you&amp;rsquo;ll excuse me, I have to go bang out some Ruby code with no regard for type errors. &lt;/p&gt;
</description>
        <pubDate>Sun, 25 May 2014 00:00:00 -0400</pubDate>
        <link>http://benbrostoff.github.io//2014/05/25/technical-week-8/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2014/05/25/technical-week-8/</guid>
      </item>
    
      <item>
        <title>Bootcamps v. CS Degree</title>
        <description>&lt;p&gt;My experience discussing software engineering bootcamps with friends and family has nearly always led to a misunderstanding wherein people assume I&amp;rsquo;m attending a multi-year CS program at an accredited university. I understand this assumption - I received a BS from Duke University in Economics in 2012 and understand universities from a signaling theory perspective in most cases carry more weight than a bootcamp &amp;ldquo;degree&amp;rdquo;. &lt;/p&gt;

&lt;p&gt;I also know well the things that universities teach that Dev Bootcamp (DBC) - my bootcamp of choice for the next three months - does not teach. I took a number of computer science classes at Duke and have two close friends who graduated with a BS in Computer Science, both of whom I have spoken to at length regarding this very subject. Bootcamps in general are pragmatic - similar to vocational school, they&amp;rsquo;re more than willing to offer a &amp;ldquo;how&amp;rdquo; without a &amp;ldquo;why&amp;rdquo;. From my experience, DBC has actually been quite good at &amp;ldquo;why&amp;rdquo;, but probably not anywhere close to a university. From speaking to my two aforementioned friends, a university CS degree should give you background in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;How computers work at the most granular level - assembly language, gateways, interpreters, etc.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Algorithms and data structures&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Discrete mathematics (I took this course    at Duke and found it extremely useful in    a &amp;ldquo;how to think about a problem&amp;rdquo; sense)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Key concepts like recursion, memory usage, trees, etc.(DBC does offer to a degree from my experience)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Comfort in one or more programming languages, with Java generally being the language most schools teach&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I&amp;rsquo;m sure I&amp;rsquo;m forgetting a host of other things - I also acknowledge the electives you take have a huge impact - schools offer courses in all varieties of languages and subject matter&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In contrast, most bootcamps from my research get you the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Comfort in one or more programming languages&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Comfort in web development&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Understanding of concepts front-end and back-end developers need to know: the stack, version control (using Git and GitHub), the DOM, databases, etc. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Again, I haven&amp;rsquo;t been through the nine weeks of in-person course work DBC offers (my start date is June 2nd), so please comment as you see fit&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally, the learning styles / cultures of each institution are markedly different.&lt;/p&gt;

&lt;p&gt;Universities give you individual classes with a midterm and final to match. You can devote as much or as little time to them as you please.&lt;/p&gt;

&lt;p&gt;DBC in effect forces all students to devote all their time to learning (hence the boot in bootcamp). Most students I&amp;rsquo;ve spoken to claim they are in the classroom 8 am - 8 pm M - F for nine weeks, and usually devote a large chunk of their weekends to working. &lt;/p&gt;

&lt;p&gt;DBC is huge on students collaborating with eachother and requires students to pair program on a near daily basis - from my experience, universities generally do not have this requirement (perhaps there&amp;rsquo;s one or two group projects throughout the semester). There&amp;rsquo;s also no tests or review sessions; learning is rapid fire and students who do not understand need seek counsel elsewhere (and to be clear, elsewhere could mean an instructor - what it does not mean is that the class will slow down to accomodate students who learn at a &amp;ldquo;slower&amp;rdquo; pace). &lt;/p&gt;

&lt;p&gt;DBC and other bootcamps as a result probably produce many different types of graduates. Some have tapped the program for all its worth - done all the exercises, asked the instructors myriad questions, attended all the lectures and classes, etc. I know I&amp;rsquo;ve also studied in excess of a hundred hours in preparation for DBC. Many students prior to attending DBC already have web development, data science, or other useful experience.&lt;/p&gt;

&lt;p&gt;While college also produces many different types of graduates, the preponderance of tests and evaluations makes it such that students spend a lot of time on review. After four years, students probably are more similar in their knowledge base. They&amp;rsquo;re also probably more secure in what they know having been tested on it multiple times. While DBC does evaluate students periodically, it&amp;rsquo;s difficult to &amp;ldquo;fail&amp;rdquo; for lack of a better word (although a handful of students drop out every cohort or are asked to repeat units). As such, the signaling power from graduating from DBC is no doubt weaker than a CS degree. &lt;/p&gt;

&lt;p&gt;Yet, I fully believe there are instances where bootcamp students come out of bootcamps more prepared to be value-add to companies than university students, and vice versa. As are so many things in life, it largely depends on the individual. &lt;/p&gt;

&lt;p&gt;What follows are some of the reasons I believe DBC is a better fit for me than a university:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I like focusing on one thing for long periods of time.&lt;/strong&gt; I never really enjoyed balancing 5-7 classes throughout high school and college. I think the Colorado College model of &amp;ldquo;one class at a time&amp;rdquo; is interesting in this respect - ask students to focus on one thing and they&amp;rsquo;ll probably do it. Ask them to focus on multiple things and certain things are inevitably sacrificed.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;I think learning any language largely depends on getting a huge volume of reps over several or more months.&lt;/strong&gt; My attempts to learn Java in Duke CS classes did not benefit from (i) only having two classes a week and (ii) only coding maybe three times a week - during class and when doing homework. Bootcamps force me to code 12 hours a day for nine weeks - I&amp;rsquo;ve also coded over 100 hours in preparation for DBC. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;DBC / bootcamp instructors have worked for large and small companies in front-end and back-end capacities.&lt;/strong&gt; Professors and TAs usually want to be in academia for life (again, I acknowledge this is a generalization). DBC is good in relaying the latest developer tools, debuggers, libraries, etc. In college, you generally would have to find this out yourself.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;There is something to be said for vocational training v. academic training.&lt;/strong&gt; I&amp;rsquo;m at a point in my life where I have worked   for two years and understand well how difficult it can be to value-add without the proper training. As a new software engineer, I want to have skills that matter - I also want to have a way of thinking that matters, which is one area a university is likely superior to a bootcamp, but I&amp;rsquo;ve also come to believe skills and ways of thinking are highly interrelated. &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;The bootcamp / DBC curriculum is updated every single month to accomodate industry changes - universities have been teaching the same classes for decades.&lt;/strong&gt; Curriculum changes occur extremely slowly in universities. Changes are decided by large committees and debated ad nauseum. Students are the victims here as the curriculum becomes further and further divorced from current work in the respective discipline. Because bootcamps are so small and have a better central model of decision making, they are quick to respond to input from companies who have hired graduates and change curriculums accordingly. I&amp;rsquo;m not saying here that the workplace should dictate what people learn - I&amp;rsquo;m merely saying that if one&amp;rsquo;s goal is to be a value-add in the workplace, company feedback is a good place to start.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Importantly, I want to revisit this post after I graduate from DBC. It is difficult to evaluate a bootcamp without having attended one or a university CS program when I have a BS in Economics (although I took CS classes). &lt;/p&gt;

&lt;p&gt;Finally, I believe more writing on this subject is highly necessary to help future students decide how to invest in themselves. Bootcamps are such a new educational model in  software engineering that they deserve more attention from writers / programmers who can objectively evaluate their offerings.  &lt;/p&gt;
</description>
        <pubDate>Fri, 23 May 2014 00:00:00 -0400</pubDate>
        <link>http://benbrostoff.github.io//2014/05/23/cultural-week-8/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2014/05/23/cultural-week-8/</guid>
      </item>
    
      <item>
        <title>Precursor to a New Journey</title>
        <description>&lt;p class = &quot;blogpost&quot;&gt;June 2nd marks the beginning of my DBC cohort date in New York.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;To be frank, I feel I&amp;rsquo;m not exagerrating when I claim that signing up for DBC was the most difficult decision of my life (which goes to show you the relative lack of events that have occurred in my life thus far). I left a comfortable job in Wells Fargo&amp;rsquo;s asset-backed finance division in Charlotte, where I very much liked my colleagues and was well practiced at the investment banking duties associated with the position.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;Yet, computer science and programming I had flirted with for several years, and I found as time progressed it was a flirtation that turned into something far more powerful. I am someone with a natural inclination to take things apart and figure out how they work. I like to draw; I love to build; I live to write.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;I dabbled in a few CS classes at Duke and wish I had done more - the reason I didn&amp;rsquo;t I can purely attribute to already having achieved an Economics degree in my junior year and naturally assuming I would have some type of career in business / finance. Besides, I got A&amp;rsquo;s in all my economics classes and B&amp;rsquo;s in the CS I took (basic Java, discrete mathematics)&amp;hellip; but perhaps this was to be expected due to Duke&amp;rsquo;s massive grade inflation in the former and lack thereof in the latter.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;In reflecting, I&amp;rsquo;ve come to realize that my work in banking convinced me I was &lt;i&gt; good &lt;/i&gt; at something. It was easy to put together slide decks and elementary models and write credit memos once I had done it for a year. The volume of work I did created something like fulfillment in my life.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;I know intimately, though, that work for work&amp;rsquo;s sake is surface fulfillment. Volume is not quality. And having one&amp;rsquo;s work be both challenging and intellectually stimulating in part renders work meaningful. Moreover, work needs to serve a greater purpose - chiefly, the advancement of technology that benefits all.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;I&amp;rsquo;m a firm believer in one&amp;rsquo;s job being tied to one&amp;rsquo;s passion, if not the exact same. I consider computers humanity&amp;rsquo;s most wonderful and incredible invention, and I would be amiss if I did not gain an education in how to use them to their fullest extent: writing useful software. I am proud to undertake the craft of software engineering, and excited for the challenge that lies ahead.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;I covered in a previous post the idea of stereotype threat. It seems to me that stereotype threat covers not only groups of people, but ideas. I once believed that we should do what we&amp;rsquo;re &amp;ldquo;good&amp;rdquo; at. It seems logical that what I displayed a talent for should be my vocation. Experience has borne out the idea that motivation is intimately tied to intellectual curiousity and pursuing challenges that push us as thinkers. Computer science and programming has given me an intellectual motivation that economics never did, and I welcome my pending career change.&lt;/p&gt;
</description>
        <pubDate>Sun, 18 May 2014 12:00:00 +0000</pubDate>
        <link>http://benbrostoff.github.io//2014/05/18/cultural-week-7/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2014/05/18/cultural-week-7/</guid>
      </item>
    
      <item>
        <title>SQL Injection</title>
        <description>&lt;p class = &quot;blogpost&quot;&gt;SQL (Structured Query Language) injection is a common method used by malicious users to query databases via user entry fields. The malicious user more or less &amp;ldquo;tricks&amp;rdquo; the database into revealing sensitive information by entering SQL commands. The &amp;ldquo;trick&amp;rdquo; is a bit of a misnomer, as the code behind the SQL is just functioning properly, and the malicious user (let&amp;rsquo;s call it hacker going forward) is taking advantage of &amp;ldquo;unsanitized&amp;rdquo; code. The hacker may access, alter or delete information through entering simple SQL commands into user fields and guessing field or table names in the database.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;SQL injection is a key concept for any aspiring programmer to gain knowledge of in that (i) it is an easy attack mechanism for potential hackers to implement (apps such as Havji allow for automated injection without knowledge of SQL) and (ii) defenses against SQL injection are similarly easy to implement (although offense and defense both continue to evolve).&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;Defense against SQL injection in part involves &amp;ldquo;sanitizing code&amp;rdquo;. One example of sanitization is controlling input into user fields. By only allowing specific characters to be input into user fields, hackers are unable to enter in certain SQL commands into such fields.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;Sanitization, however, is by no means fail-safe, and perhaps the optimal solution here is to &lt;a href =&quot;http://www.esecurityplanet.com/hackers/how-to-prevent-sql-injection-attacks.html&quot; target=&quot;_blank&quot;&gt;avoid constructing SQL queries with user input&lt;/a&gt;. Instead, SQL queries would be made via prepared statements or stored procedures as opposed to full queries. Other defenses available to programmers include data encryption, data segregation, permission limitations and firewalls.&lt;/p&gt; 

&lt;p class = &quot;blogpost&quot;&gt;Overall, SQL injection has received its share of attention over time due to some &lt;a href =&quot;http://www.esecurityplanet.com/hackers/how-to-prevent-sql-injection-attacks.html&quot; target=&quot;_blank&quot;&gt;extremely high profile attacks making use of the technique&lt;/a&gt;. Concurrently, defenses against SQL injections have also involved, meaning the cybersecurity experts of the world are making it increasingly difficult for the hackers. All programmers would be well advised to make use of the significant literature on SQL injection defenses. &lt;/p&gt; 
</description>
        <pubDate>Sun, 18 May 2014 00:00:00 -0400</pubDate>
        <link>http://benbrostoff.github.io//2014/05/18/technical-week-7/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2014/05/18/technical-week-7/</guid>
      </item>
    
      <item>
        <title>OOP v. Functional Programming</title>
        <description>&lt;p class = &quot;blogpost&quot;&gt;The main difficulty in describing the difference between object oriented and functional programming is that each of the two &amp;ldquo;types&amp;rdquo; of programs are, at best, vaguely defined.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;Indeed, it seems to me that anecdotally, the concept of functional programming is significantly misunderstood by the general programming community, and &lt;a href=&quot;https://twitter.com/quackingduck&quot; target=&quot;_blank&quot;&gt; Myles Byrne &lt;/a&gt; in a lecture from late April stressed this point repeatedly. From Byrne&amp;rsquo;s perspective, the two largest misunderstandings of functional programming are that (i) functional programming is about passing functions into other functions and (ii) functional programming is about lambdas (a misconception perhaps created by its &lt;a href=&quot;http://en.wikipedia.org/wiki/Functional_programming&quot; target=&quot;_blank&quot;&gt; Wikipedia page&lt;/a&gt;.)&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;Byrne spoke extensively about statelessness and immutability being at the heart of functional programming. The state of a &amp;ldquo;functional&amp;rdquo; program at any given time will not impact its output; &lt;a href=&quot;http://stackoverflow.com/questions/353912/functional-programming-state-vs-reassignment&quot;&gt; objects in functional programming are a sequence of immutable values &lt;/a&gt;. A function&amp;rsquo;s output is only dependent on its input (i.e. calling the function does not affect state), and thus functional code by some commentators is considered easier to read than OOP code or other programming styles&#39; code, since the reader need not keep track of state.&lt;/a&gt;.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt; In contrast, programs in the OOP style are not stateless and objects exist as instances of classes rather than a sequence of immutable values. &amp;ldquo;Stateful&amp;rdquo; expressions are part of OOP - functions can change objects. Functions in OOP (can) change the state of the program: this outcome is not acceptable in functional programming.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;Additionally, a hallmark of functional programming is that it does not introduce &amp;ldquo;side effects&amp;rdquo;. What is meant here is that passing the same argument into a given function will produce the same output each time. There are no side effects to calling on a function: the same input always leads to the same output. &lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;In the below, I&amp;rsquo;ve tried to demonstrate a &amp;ldquo;pure&amp;rdquo; functional programming function in JavaScript in comparison to &amp;ldquo;non-pure&amp;rdquo; function (I chose JavaScript because the consensus thinking seems to be that this language can be adopted as a &amp;ldquo;part&amp;rdquo; functional programming language - I did not find through my research the same enthusiasm for Ruby as a functional programming language, although this may just be due to the widespread use of JavaScript compared to Ruby to begin with). The major difference is that the pure function does not change the value of any variables.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/BenBrostoff/3b00f0e3d712a7402765.js&quot;&gt;&lt;/script&gt;

&lt;p class = &quot;blogpost&quot;&gt; My experience in OOP (full disclosure: I have never coded in a functional programming style) is that there are scenarios wherein you want your functions to produce side effects. &lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt; Consider the case of a class that has a method keeping track of objects created within the class. This function (method if we&amp;rsquo;re discussing Ruby) will produce different results each time a new object is created. Additionally, the class variable is being mutated each time the function is called, meaning the method is effectively changing the state of the program. I&amp;rsquo;ve tried to demonstrate this concept in the example below. &lt;/p&gt; 

&lt;script src=&quot;https://gist.github.com/BenBrostoff/698f0ed90b2e1164a4f7.js&quot;&gt;&lt;/script&gt;

&lt;p class = &quot;blogpost&quot;&gt; I would be amiss without mentioning that functional programming relies on a number of other practices I will not go into detail on here, as this post is meant to be fairly high-level. However, to become a proficient functional programmer, it seems to me one must (and I say must because these are often the only ways of maintaining immutability and statelessness) use first class / higher order functins, recursion over for / while loops and closures. I found Stephen Young&amp;rsquo;s blog post to be an excellent primer on these concepts &lt;a href=&quot;http://stephen-young.me.uk/2013/01/20/functional-programming-with-javascript.html&quot;&gt; and have linked it here &lt;/a&gt;.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt; Finally, just as there are widely heralded OOP languages (Ruby, Python, Java - note that Python and Java also fall into other camps), functional programming has its favored languages for getting the job done. Haskell, Hope, and Lisp are some of the notable ones. &lt;a href = &quot;http://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Object-oriented_class-based_languages&quot;&gt; Although by no means a reliable source, this Wikipedia entry attempts to sort major programming languages by camp.&lt;/a&gt; &lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt; One would think this post should naturally conclude with some &amp;ldquo;which style is better&amp;rdquo; commentary. I profess not to have a good answer here because I have zero experience with functional programming, and even those with significant experience in functional programming are unsure.&lt;p/&gt;

&lt;p class = &quot;blogpost&quot;&gt;Based on my research, it seems the major drawback of functional programming is that it takes significant displine to write in this style, especially in languages that aren&amp;rsquo;t pure &amp;ldquo;functional&amp;rdquo; languages at heart. Many of the write-ups I read on functional programming in JavaScript showed functional and non-functional code snippets. Functional programming is in most languages a choice, and often it&amp;rsquo;s a harder choice depending on the programmer&amp;rsquo;s tendencies. For instance, the idea of using recursion over loops all the time may simply not be pragmatic for a programmer under time constraints (alternatively, it could be the fastest way to solve a problem).&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;The main advantage functional programming has over OOP in my opinion is that it&amp;rsquo;s easier to read code in this style. Because a functional program is both stateless and its variables immutable, the reader of the code does not face moving targets in the same way he or she would reading code in the OOP mode. In terms of maintainability and testing, it would seem to me that functional code wins over OO code every time. This advantage only widens when one considers how difficult it can be to read OO code if the program contains mutliple class dependencies and is not well structured in the &lt;a href = &quot;http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330&quot;&gt; Sandi Metz / POODR sense.&lt;/a&gt; 

&lt;p class = &quot;blogpost&quot;&gt;Yet, OOP&amp;rsquo;s popularity over functional programming at present means that a coder well trained in OOP principles will have a large group of friends to work with (to be clear, popularity is, of course, largely overrated). Combined with the fact that a functional programming approach to a problem may not be the quickest way to solve the problem, I could foresee many scenarios where OOP is preferable to functional programming.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;I&amp;rsquo;d venture to guess that both will play a large role in the future of programming styles. &lt;/p&gt;
</description>
        <pubDate>Wed, 07 May 2014 12:00:00 +0000</pubDate>
        <link>http://benbrostoff.github.io//2014/05/07/technical-week-6/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2014/05/07/technical-week-6/</guid>
      </item>
    
      <item>
        <title>Stereotype Threat</title>
        <description>&lt;p class = &quot;blogpost&quot;&gt;I&amp;rsquo;ll begin by getting the obvious out of the way - I&amp;rsquo;m a white, heterosexual male who would be difficult to pick out of a lineup. I acknowledge fully I have never experienced &lt;a &quot;href http://en.wikipedia.org/wiki/Stereotype_threat&quot; target=&quot;_blank&quot;&gt; stereotype threat&lt;/a&gt; and consequently would be unable to relate to someone who has. &lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;I am comfortable enough to say I am probably someone who has certain expectations upon meeting another person These expectations are one part experience and one part my own media consumption (or some mixture thereof). They are what I think of as &amp;ldquo;generic&amp;rdquo; assumptions, but nonetheless, they are no doubt assumptions that feed into stereotype threat.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;I can remember feelings upon meeting certain people that confirm this suspicion. The first time I played in a morning basketball scrimmage at my local JCC, I assumed the black guy was the best player. He was. When I walked into my multi-variate calculus class in college, I assumed the Asians were math majors and the white kids were economics majors (multi-variate was a required course for economics majors at Duke). That assumption was swiftly proved false. When I discovered my associate at my first job was a muscle-bound, New Jersey native, I thought the only thing we&amp;rsquo;d have in common would be sports. We found common ground on cooking, fiction, travel - and, among other things, sports. I&amp;rsquo;ve found my assumptions turn out to be right, wrong and a mix of both.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;It&amp;rsquo;s not a popular thing to say, but there are times stereotypes can be useful - a super athletic black guy in your morning scrimmage should be guarded closely if you&amp;rsquo;re on defense - a slightly overweight, Jewish guy (like myself), less so. I&amp;rsquo;d like to think I change my assumptions over time as they are proved / disproved. Again, exceptions exist everywhere, but it&amp;rsquo;s nice to have somewhere to start when trying to do business or form friendships with new people. If you have a passion for German history, you would be well advised to tread lightly around a Jewish person. I don&amp;rsquo;t believe this is deliberate stereotyping - it&amp;rsquo;s common courtesy and, to a certain extent, calculated empathy (&lt;e class=&quot;g&quot;&gt;&lt;/e&gt;. as a practicing Jew, I can say most Jewish people, including myself, feel annoyed when we hear car enthusiasts trumpeting the merits of BMW without mentioning the company&amp;rsquo;s role in WWII).&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;Yet, assumptions are the basis of stereotype threat - there is no threat without assumptions.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;It seems to me, though, that there is no realistic means of totally eliminating assumptions. Every minority has to deal with stereotype threat. It is an unpleasant fact of life, but a reality. Although I cannot speak from experience on stereotype threat specifically, I find the unpleasant facts of life are best dealt with by facing them head-on and realizing they are unavoidable. &lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;I believe I can do my small part to negate the impact of stereotype threat by keeping my assumptions to myself initially, and changing them accordingly as the facts present themselves (let&amp;rsquo;s recall not all stereotypes lead to negative baseline assumptions - indeed, it seems to be the case that certain minorities are excellent at certain jobs, and the numbers don&amp;rsquo;t deny this argument - consider Jews&#39; overrepresentation in comedy and finance relative to their representation on an absolute basis in the US). The best way to defuse the threat of stereotype is to weigh the (ever-changing) reality against the stereotype itself.&lt;/p&gt;

&lt;p class = &quot;blogpost&quot;&gt;Indeed, realities change quickly, and so should our assumptions. &lt;/p&gt;
</description>
        <pubDate>Wed, 07 May 2014 12:00:00 +0000</pubDate>
        <link>http://benbrostoff.github.io//2014/05/07/cultural-week-6/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2014/05/07/cultural-week-6/</guid>
      </item>
    
      <item>
        <title>Introduction to Ruby Classes</title>
        <description>&lt;p&gt;Classes to a degree are hallmarks of object oriented programming. Classes serve as templates for creating objects, and the purpose of classes in Ruby is no exception. I am relatively new to Ruby and this post will serve as a basic introduction to creating classes.&lt;/p&gt;

&lt;p&gt;Below is a short class I wrote for the purpose of tracking information on NBA players. Using the class, entitled NBAPlayer (classes are always capitalized, per Ruby convention) you can create &lt;b&gt;instances&lt;/b&gt; of NBA Players, with the respective information attributes of each instance known as &lt;b&gt;instance variables&lt;/b&gt;. Methods within the class can take arguments or have no arguments; their purpose can be to display information, manipulate instance variables or do any other number of different functions.&lt;/p&gt;

&lt;p&gt;I have provided comments in the code below, but a few initial thoughts: &lt;p/&gt;

&lt;ul&gt;
&lt;li&gt;The class variable (prefaced by @@) no_players can be accessed by any method in the class and is the same for all instances of the class. Take a look at the dirk and pierce objects that follow in the code - once pierce is created, no_players is 2 for both pierce and dirk.&lt;/li&gt;
&lt;li&gt;Initialize is an instance method which creates our instance variables, assigning them the values given when the object is created. Initialize also adds one to no_players, which forms the basis of the current_player_count method.&lt;/li&gt;
&lt;li&gt;The remaining methods are class methods which output values based on (in some cases) arguments that are passed in or manipulation of the instance variables.&lt;/li&gt;
&lt;/ul&gt;

&lt;script src=&quot;https://gist.github.com/BenBrostoff/3d6c87563acb45f4bae2.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Running this code outputs the following to the console. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dirk Nowitzki is 36 years old.&lt;/li&gt; 
&lt;li&gt;Our state of the art program recommends that Dirk Nowitzki start at C.&lt;/li&gt; 
&lt;li&gt;Dirk Nowitzki is in the right position.&lt;/li&gt;
&lt;li&gt;Dirk Nowitzki is one of 1 object(s) created using this program.&lt;/li&gt; 
&lt;li&gt;Paul Pierce is 37 years old.&lt;/li&gt; 
&lt;li&gt;Our state of the art program recommends that Paul Pierce start at PF.&lt;/li&gt; 
&lt;li&gt;Paul Pierce is currently out of position.&lt;/li&gt;
&lt;li&gt;Paul Pierce is one of 2 object(s) created using this program.&lt;/li&gt; 
&lt;/ul&gt; 

&lt;p&gt;One can in part see from this example the inherent usefulness of a class. Classes (which are objects of the class Class, by the way, in Ruby) provide a means of giving objects utility from a programming perspective: the class an object is in determines the methods you can call, the information about that object, etc. Classes are also objects, as previously stated. In future posts, I intend to explore more principles of object oriented programming and the role of classes in OOP. &lt;/p&gt;
</description>
        <pubDate>Sun, 04 May 2014 00:00:00 -0400</pubDate>
        <link>http://benbrostoff.github.io//2014/05/04/technical-week-5/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2014/05/04/technical-week-5/</guid>
      </item>
    
      <item>
        <title>Computer Science Education</title>
        <description>&lt;p&gt;It&amp;rsquo;s an oft-mentioned issue in education, one that is beginning to gain some traction at the local and national levels and even at the White House: the lack of computer science built into the K-12 curriculum. I profess not to know whether &amp;ldquo;we&amp;rdquo; (and I suppose I mean the federal government) are on top of this issue, although Code.org and efforts like it seem like a start. This post is not meant to serve as a normative diagnosis of what we should be doing with regard to computer science education. Rather, it&amp;rsquo;s a relation of my own experience as a now aspiring programmer.&lt;/p&gt;

&lt;p&gt;I had never coded until my sophomore year of college. Until my intro Java class at Duke, I could not tell you a single programming language, how software was written, the difference between desktop and web-based software, etc. My understanding of the internet was more or less limited to the websites I visited and the applications I used. When I received my first smartphone at age 21, the entire transition seemed rather natural. Oh, now I have this piece of superior technology that everyone else has. I am more in awe of mobile apps now than I was in three years ago because I&amp;rsquo;m only just beginning to understand their origins and power. Indeed, I&amp;rsquo;m only just beginning to hear and understand computer science terms that are fundamental to how we conduct our daily lives.&lt;/p&gt;

&lt;p&gt;I look back at my K-12 education and try to piece together exactly why I never looked into or learned about computer science or programming. There are the obvious answers of course: no classes were offered, my parents, siblings and friends had no interest in programming computers, etc. The obvious answers in retrospect do not really hold weight, in that I now wonder why I had no interest in how computers worked.&lt;/p&gt;

&lt;p&gt;I played through some of The Way Things Work (David Macaulay and Neil Ardley) as a child. I asked questions about the seasons, light bulbs, cars, and all the other things a child might be interested in. Fascinatingly, though, it never really occurred to me to ask how pixels formed on a screen (be it TV or computers), or why I could click on At Ease icons on our family&amp;rsquo;s old Mac and be brought to a variety of different places, or how CDs or floppy disks were so small but held so much data (and little did I know that those things would be gargantuan by today’s standards).&lt;/p&gt;

&lt;p&gt;In what I remember of my elementary and middle school years, adults sometimes liked to pose the “how does X work” questions and provide the answers. Most science teachers served this function. But computers rarely came under the line of questioning. Even as massive technological changes (by my standards) happened under my nose, adults never really provided commentary or answers. One day it just so happened that your sister could pick up the phone while you were on the internet and nothing would happen. The next day there was no America Online CD or seven step log-in process - you just clicked on a Microsoft Explorer icon and you were online. You don’t need to page your mother anymore, Benjamin - you can text her on this new phone that fits in your pocket. Thanks, Dad.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not suggesting here it&amp;rsquo;s an adult&amp;rsquo;s responsibility to inform children of why and how certain things are happening in the world. I&amp;rsquo;m an adult now and could not bear this responsibility. But why don&amp;rsquo;t we, the community of adults, feel at all obligated to explain certain elements of technology to our children?&lt;/p&gt;

&lt;p&gt;At a certain level, children interpret this indifference to mean &amp;ldquo;it&amp;rsquo;s not all that important&amp;rdquo; (or at least I did). In part because no one really made me give notice to changes in computers, the internet, AI, mobile phones, etc., I ignored it and moved along. My working assumption was calculus, physics, and even classic novels were &amp;ldquo;more important&amp;rdquo; - here is where my attentions should be focused on. &lt;/p&gt;

&lt;p&gt;I find myself now in a weird state of affairs - a 24 year old adult with a new child like curiosity in computers. I find myself marveling at previous things I held to be normal. The mere fact that every pixel on your screen is controlled by an algorithm elicits wonder. Now that I know the difficult in coding a basic tic-tac-toe bot, I can be floored by alpha-beta pruning in chess algorithms.&lt;/p&gt; 

&lt;p&gt;I wonder often how my views on the world would have been shaped had I learned to code at a yong age. Brian Fitzpatrick, in his interview in Peter Seibel&amp;rsquo;s &lt;i&gt; The Art of Coding&lt;/i&gt;, provides a bit of color here:&lt;/p&gt;

&lt;blockquote class = &quot;blogpost&quot;&gt;This was one of my first programs-it was something like K equals grab the next char. Then I said if K equals &amp;ldquo;a&amp;rdquo;, print &amp;ldquo;a&amp;rdquo;; if K is &amp;ldquo;b&amp;rdquo;, print &amp;ldquo;b&amp;rdquo;. I pretty much did every letter, number, and some punctuation. Then at one point I was like, &amp;ldquo;Wait, I could just say, `Print the variable!&amp;rdquo;&amp;lsquo; and I replaced 40 lines of code with one. I was like, &amp;ldquo;Holy shit, that was awesome!&amp;rdquo; That was some major abstraction for a six year old. &lt;/blockquote&gt;

&lt;p&gt;Although this particular quote seems pretty funny at first glance, it’s also somewhat incredible a six year old can come to an important realization about the world at large through programming. The insight about variables here is one you could easily imagine being important in any discipline: the idea that one thing can stand for many things. Indeed, there&amp;rsquo;s no question such an insight requires a higher level of thinking than most six year olds are capable of. That passage alone is proof many times over that we as an &amp;ldquo;adult society&amp;rdquo; need to introduce children to porogramming as early as possible.&lt;/p&gt;

&lt;p&gt;Coding develops new branches in the mind. Anyone who knows how to program thinks about the world differently. Fundamentally, how one perceives the relationship between humans and machines is largely a function of their experience in programming. Imagine writing a critical review of The Matrix. Your opinion on that movie to a certain extent has to be dictated by your knowledge of computer programming. &lt;/p&gt;

&lt;p&gt;When I see any device reliant on being &amp;ldquo;programmed&amp;rdquo;, I start to think about how. Classes, methods, variables, conditionals, etc. My appreciation for these devices is an infinite order of times larger than before I started to study programming; my interest in them has been inifinitely magnified as well.&lt;/&gt;  

&lt;p&gt;I find new historical figures that in my adulthood are the Michael Jordans and Tom Bradys of my youth. John McCarthy. Donald Knuth. Hal Ableson. Gerald Jay Sussman. Paul Graham. The intelligence of these guys makes them something else in my mind: worthy of being on the same plane as a Franklin, an Edison or a Tesla.&lt;/p&gt;

&lt;p&gt;All of the above is really to say that programming and the study of computer science has had a profound impact on my life. I feel excited every day to continue improving as a programmer and learn more about the history and future of computer science. One of the greatest gifts we as adults can pass onto our children is this education. &lt;/p&gt; 
</description>
        <pubDate>Sun, 04 May 2014 00:00:00 -0400</pubDate>
        <link>http://benbrostoff.github.io//2014/05/04/cultural-week-5/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2014/05/04/cultural-week-5/</guid>
      </item>
    
      <item>
        <title>Enumerable</title>
        <description>&lt;p&gt;Enumerables is a Ruby module that contains various methods for use in arrays. I find map particularly useful, as it&amp;rsquo;s the easiest way (in my opinion) to modify all elements of an array with a &amp;ldquo;universal&amp;rdquo; rule. In the example below, I take an array of numbers and add one to each element. I show map in its destructive (map!) and non-destructive forms as well. &lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/BenBrostoff/11351284.js&quot;&gt;&lt;/script&gt;

&lt;p&gt; Predictably, because Enumerables was built for arrays, changing keys or values in a hash is not as easy via the map method. Using the map method on a hash will yield an array. &lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/BenBrostoff/11351423.js&quot;&gt;&lt;/script&gt;

&lt;p&gt; I personally don&amp;rsquo;t have many instances where I need to do that, so I would rather use the each method. &lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/BenBrostoff/11351368.js&quot;&gt;&lt;/script&gt;

&lt;p class = &quot;blogpost&quot;&gt; Others have encountered this issue before in Ruby, and it&amp;rsquo;s covered in some detail via &lt;a href=&quot;http://stackoverflow.com/questions/812541/ruby-change-each-value-in-a-hash-with-something-like-collect-for-arrays&quot; target=&quot;_blank&quot;&gt; this S/O post &lt;/a&gt;. As per usual, there are many ways to do certain tasks in Ruby, and it&amp;rsquo;s largely personal preference how you do them.&lt;/p&gt;
</description>
        <pubDate>Sun, 27 Apr 2014 00:00:00 -0400</pubDate>
        <link>http://benbrostoff.github.io//2014/04/27/technical-week-4/</link>
        <guid isPermaLink="true">http://benbrostoff.github.io//2014/04/27/technical-week-4/</guid>
      </item>
    
  </channel>
</rss>